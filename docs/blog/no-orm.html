<!DOCTYPE html>
<html><head><meta content="text/html; charset=utf-8" http-equiv="content-type"><meta content="width=device-width,initial-scale=1.0,viewport-fit=cover" name="viewport"><title>Eduard's blog</title><link href="../assets/tui/tuicss.min.css" rel="stylesheet" type="text/css"><link href="../style.css" rel="stylesheet" type="text/css"></head><body><nav class="tui-nav"><ul><li><a href="https://duskpoet.github.io/about/index.html">Home</a></li><li><a href="https://duskpoet.github.io/about/blog.html">Blog</a></li></ul></nav><div class="tui-bg-cyan-white"><div class="container article"><div class="row"><div class="col s12 m8 l8"><a href="https://github.com/duskpoet/no-orm-example">Github</a><br><h1>Backend without ORM</h1><h2>Few words about ORM</h2><p>ORM (Object-relational mapping) is a programming technique that allows you to map data from external storage (such as databases) to your local programming objects. This approach allows developers to abstract from database specificities and to perform CRUD operations as common function calls. This is beneficial since we don't have to know actual database syntax, some ORMs can even work on SQL and NoSQL databases simultaneously. But this article's title doesn't say "Why everyone should always ORMs", so I want to point out the downsides of ORMs and suggest an alternative approach.</p><h2>Why you don't need ORM</h2><h3>Communication with database</h3><p>The lowest level representation of the database data is pure bytes (well it's actually electrons stored and moved in wires and semiconductors if we go all the way down, but we will stay in the software field). So when any driver talks to the actual database over the network it sends and receives packets of bytes. Further, based on the database protocol, which describes how to read and process these bytes, the driver transforms the bytes into meaningful data structures. So, as we can see, the database driver works sort of like an ORM here: it maps the raw data into your programming language constructs. And ORM maps this data even further into different constructs. The data received from the driver is ready to be used in your application. That is the first point on why you don't need ORM.</p><h3>Raw data is powerful</h3><p>So you read some data from the database and you get arrays (or lists, or sequences, or an iterator, depending on your language and driver of choice) in return. Right of the box, you have powerful tools to work with that data, because your standard library contains many functions that work on arrays and maps. On contrary, these functions may or may not work on ORM-specific objects. Also, raw data is perfectly serializable and is ready to be transferred via wire.</p><h3>Does your ORM support tests</h3><p>When you write unit tests for entities that work with your stored data, ideally you want to be ignorant of the database layer. Raw data is decoupled from its origin by nature and can be mocked as you prefer. ORM, on the other hand, is dependent on its implementation and may support some mock storage, otherwise, you have to always execute tests in front of some database.</p><h3>ORM libraries authors don't know about your domain</h3><p>But you do. Sometimes more specific solutions can be beneficial for your project. Maybe there is some addition to the generated SQL, that can vastly improve the speed of querying.</p><h3>Databases can be complex</h3><p>Beyond simple CRUD operations database can support many amazing features, like sharding, different index types, non-standard conditional operators, and non-standard built-in functions. Probably an ORM library lacks the support for many features of the database you are using. Also, if you pick an ORM library and build upon it, you are tieing yourself with that library and at some point, if there is a database solution that may be beneficial to your application domain, you may end up in a situation where you need to massively rework your codebase.</p><h3>Rich said that ORM is bad</h3><p>Seriously, if you haven't seen <a href='https://www.youtube.com/watch?v=SxdOUGdseq4'>"Simple made easy"</a> talk by Rich Hickey, do yourself a favor, it's very enlightening.</p><h2>How to build without ORM</h2><p>Let's figure out how to build our projects with the "no ORM" approach. We want to build a solution that is testable separately from the database, operates on data, and has layers with well-defined boundaries (kudos to <a href='https://www.youtube.com/watch?v=o_TH-Y78tt4'>Uncle Bob</a>). I will build an example using node, typescript, and neon (postgres). It will contain a single entity - <code>User</code> with attributes <code>name</code> and <code>age</code>.</p><h3>Model layer</h3><p>So how do we represent a model within our concept? It's just an interface! <a href='https://github.com/duskpoet/no-orm-example/tree/master/src/models/user.ts'>link</a></p><pre><code>export type User = {
  id: number;
  name: string;
  age: number;
};
</code></pre><p>If later we want to add some methods, that operate on <code>User</code> somehow, then we just write a function that accepts <code>User</code> as a parameter or returns a <code>User</code> shaped object. Now we want to connect the <code>User</code> entity to the database: store it, retrieve it, modify and delete it.</p><h3>Repository layer</h3><p>Now let's add the entity <code>Repository</code>. It will have CRUD methods that operate on raw data and will perform database operations. <a href='https://github.com/duskpoet/no-orm-example/tree/master/src/types/dbAdapter.ts'>link</a></p><pre><code>export type Repository&lt;T extends Record&lt;string, any&gt;&gt; = {
  name&#40;&#41;: string;
  create&#40;data: Omit&lt;T, &quot;id&quot;&gt;&#41;: Promise&lt;T&gt;;
  readMany&lt;K extends keyof T&gt;&#40;filters: Filter&lt;T, K&gt;&#91;&#93;&#41;: Promise&lt;T&#91;&#93;&gt;;
  read&#40;id: string&#41;: Promise&lt;T&gt;;
  update&#40;id: string, data: T&#41;: Promise&lt;T&gt;;
  delete&#40;id: string&#41;: Promise&lt;T&gt;;
};
</code></pre><p>The <code>Repository</code> is our missing database operations layer. It can perform all of the "get, store data" stuff. Also, if some entities require additional operations we can extend the basic <code>Repository</code> for them with additional operations like <code>createOrReplace</code> or <code>updateMany</code>.</p><h3>Database adapter</h3><p>Database adapter would be the function that returns a <code>Repository</code> instance. Here is an example of how it can look for the postgres database. <a href='https://github.com/duskpoet/no-orm-example/tree/master/src/db/adapter.ts'>link</a></p><p>If we want to test an adapter we probably would do it against a real database in a snapshot manner with something like these steps:</p><ul><li>Create a test repository using the tested adapter</li><li>Run some methods</li><li>Check that the database state matches our expectations</li></ul><p><a href='https://github.com/duskpoet/no-orm-example/tree/master/src/db/adapter.test.ts'>link</a></p><h3>Our Repository is pretty useful</h3><p>Actually, our Repository instance is not only good for database management. For example, we can build REST API from it. <a href='https://github.com/duskpoet/no-orm-example/tree/master/src/server/generateApi.ts'>link</a> And write a test for that implementation as well. <a href='https://github.com/duskpoet/no-orm-example/tree/master/src/server/generateApi.test.ts'>link</a></p><h2>Conclusions</h2><h3>I gotta be honest</h3><p>Fairly, the current state of ORMs is not as bad as it was before. There are modern frameworks like Prisma, that acknowledge some of the problems I described above. For example, Prisma generates a client, that returns just typed data when using built-in query methods, so it is decoupled by design. I'd say it is a good sign when you can view the database framework as an advanced driver. Still, using Prisma makes it very hard to migrate to an unsupported database, so you need to keep that in mind.</p><h3>The TL;DR</h3><p>Probably the main thought I want to convey is: design layers of your application in advance and with thinking ahead. And since it's almost impossible to predict the functionalities your application should provide in five years, two years, or one year you need to create a very flexible architecture, and layering your designs with well-defined boundaries is the best approach from what I know.</p></div></div></div></div></body></html>